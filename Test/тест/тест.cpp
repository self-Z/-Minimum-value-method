#include <iostream> // Подключаем библиотеку для ввода-вывода
#include <iomanip>  // Подключаем библиотеку для форматирования вывода
#include <vector>   // Подключаем библиотеку для работы с векторами (можно использовать вместо массивов)
#include <climits>  // Подключаем библиотеку для работы с предельными значениями типов данных (например, INT_MAX)

using namespace std; // Используем стандартное пространство имён

int main()
{
    // --- НАЧАЛО: Ввод размерности задачи ---
    setlocale(LC_ALL, "RUS"); // Устанавливаем русскую локаль для корректного отображения кириллицы в консоли
    int n, k; // Объявляем переменные n (количество поставщиков) и k (количество потребителей)
    cout << "Введите кол-во строк (поставщики): "; // Просим пользователя ввести количество строк (поставщиков)
    cin >> n; // Считываем количество строк
    cout << "Введите кол-во столбцов (потребители): "; // Просим пользователя ввести количество столбцов (потребителей)
    cin >> k; // Считываем количество столбцов
    // --- КОНЕЦ: Ввод размерности задачи ---

    // --- НАЧАЛО: Объявление и ввод матрицы стоимостей ---
    int Matr[20][20]; // Объявляем матрицу стоимостей (максимум 20x20)
    int Matr2[20][20]; // Объявляем матрицу для плана перевозок (максимум 20x20)
    cout << "Введите матрицу стоимостей:" << endl; // Просим пользователя ввести матрицу стоимостей
    for (int i = 0; i < n; i++) { // Цикл по строкам матрицы стоимостей
        for (int j = 0; j < k; j++) { // Цикл по столбцам матрицы стоимостей
            cin >> Matr[i][j]; // Считываем элемент матрицы стоимостей
        }
    }
    // --- КОНЕЦ: Объявление и ввод матрицы стоимостей ---

    // --- НАЧАЛО: Инициализация матрицы плана ---
    for (int i = 0; i < n; i++) { // Цикл по строкам матрицы плана
        for (int j = 0; j < k; j++) { // Цикл по столбцам матрицы плана
            Matr2[i][j] = -1; // Инициализируем элемент матрицы плана значением -1 (означает "пустая клетка", не заполнена)
        }
    }
    // --- КОНЕЦ: Инициализация матрицы плана ---

    // --- НАЧАЛО: Вывод введённой матрицы стоимостей ---
    cout << "Введённая матрица стоимостей:" << endl; // Выводим заголовок
    for (int i = 0; i < n; i++) { // Цикл по строкам
        for (int j = 0; j < k; j++) { // Цикл по столбцам
            cout << Matr[i][j] << "\t"; // Выводим элемент матрицы с табуляцией
        }
        cout << endl; // Переход на новую строку
    }
    // --- КОНЕЦ: Вывод введённой матрицы ---

    // --- НАЧАЛО: Ввод запасов и потребностей ---
    int a[20] = { 0 }; // Объявляем массив a для хранения запасов каждого поставщика
    int b[20] = { 0 }; // Объявляем массив b для хранения потребностей каждого потребителя
    for (int i = 0; i < n; i++) { // Цикл для ввода запасов
        cout << "Введите A" << i + 1 << " (запас поставщика " << i + 1 << "): "; // Просим ввести запас i+1-го поставщика
        cin >> a[i]; // Считываем запас поставщика
    }
    cout << endl; // Пустая строка для разделения
    for (int i = 0; i < k; i++) { // Цикл для ввода потребностей
        cout << "Введите B" << i + 1 << " (потребность потребителя " << i + 1 << "): "; // Просим ввести потребность j+1-го потребителя
        cin >> b[i]; // Считываем потребность потребителя
    }
    // --- КОНЕЦ: Ввод запасов и потребностей ---

    // --- НАЧАЛО: Проверка баланса и добавление фиктивного пункта ---
    int sum_a = 0, sum_b = 0; // Объявляем переменные для суммарных запасов и потребностей
    for (int i = 0; i < n; i++) { // Цикл вычисления суммарных запасов
        sum_a += a[i]; // Суммируем запасы всех поставщиков
    }
    for (int i = 0; i < k; i++) { // Цикл вычисления суммарных потребностей
        sum_b += b[i]; // Суммируем потребности всех потребителей
    }

    // --- НАЧАЛО: Сбалансирование задачи ---
    if (sum_a > sum_b) { // Если запасов больше, чем потребностей
        // Добавляем фиктивного потребителя B_фikt
        b[k] = sum_a - sum_b; // Потребность фиктивного потребителя равна разнице
        for (int i = 0; i < n; i++) { // Заполняем столбец для фиктивного потребителя
            Matr[i][k] = 0; // Стоимость перевозки к фиктивному потребителю = 0
        }
        k++; // Увеличиваем количество столбцов на 1 (теперь k включает фиктивный)
    }
    else if (sum_b > sum_a) { // Если потребностей больше, чем запасов
        // Добавляем фиктивного поставщика A_фikt
        a[n] = sum_b - sum_a; // Запас фиктивного поставщика равен разнице
        for (int j = 0; j < k; j++) { // Заполняем строку для фиктивного поставщика
            Matr[n][j] = 0; // Стоимость перевозки от фиктивного поставщика = 0
        }
        n++; // Увеличиваем количество строк на 1 (теперь n включает фиктивного)
    }
    // Теперь задача сбалансирована: sum_a == sum_b
    // --- КОНЕЦ: Сбалансирование задачи ---

    // --- НАЧАЛО: Метод минимального элемента ---
    cout << endl << "Начинаем метод минимального элемента..." << endl; // Информируем пользователя

    while (true) { // Бесконечный цикл, выход из которого будет внутри
        // --- НАЧАЛО: Поиск минимального элемента среди доступных ---
        int min_cost = INT_MAX; // Инициализируем переменную для минимальной стоимости как максимально возможное целое число
        int min_i = -1, min_j = -1; // Инициализируем индексы минимального элемента как -1 (означает "не найден")

        // Проходим по всей матрице стоимостей
        for (int i = 0; i < n; i++) { // Цикл по строкам
            for (int j = 0; j < k; j++) { // Цикл по столбцам
                // Проверяем, что:
                // 1. У поставщика i еще есть запас (a[i] > 0)
                // 2. У потребителя j еще есть потребность (b[j] > 0)
                // 3. Клетка (i, j) еще не заполнена (Matr2[i][j] == -1)
                // 4. Стоимость в этой клетке меньше текущей минимальной (Matr[i][j] < min_cost)
                if (a[i] > 0 && b[j] > 0 && Matr2[i][j] == -1 && Matr[i][j] < min_cost) {
                    min_cost = Matr[i][j]; // Обновляем минимальную стоимость
                    min_i = i; // Запоминаем индекс строки
                    min_j = j; // Запоминаем индекс столбца
                }
            }
        }
        // --- КОНЕЦ: Поиск минимального элемента ---

        // --- НАЧАЛО: Проверка завершения алгоритма ---
        // Если не нашли ни одной подходящей клетки (min_i или min_j остались -1),
        // это означает, что все запасы распределены или все потребности удовлетворены.
        if (min_i == -1 || min_j == -1) {
            break; // Выходим из основного цикла
        }
        // --- КОНЕЦ: Проверка завершения алгоритма ---

        // --- НАЧАЛО: Распределение поставки ---
        // Определяем объем поставки как минимум из запаса и потребности
        int allocation = min(a[min_i], b[min_j]); // Берем минимум из запаса и потребности

        Matr2[min_i][min_j] = allocation; // Записываем объем поставки в клетку (min_i, min_j) плана

        a[min_i] -= allocation; // Уменьшаем запас у поставщика
        b[min_j] -= allocation; // Уменьшаем потребность у потребителя

        // Заметим: даже если a[min_i] или b[min_j] стали 0, цикл поиска минимального элемента
        // больше не выберет эту клетку, потому что мы проверяем a[i] > 0 и b[j] > 0.
        // --- КОНЕЦ: Распределение поставки ---
    }
    // --- КОНЕЦ: Метод минимального элемента ---

    // --- НАЧАЛО: Финальная обработка матрицы плана ---
    // Заменяем все оставшиеся -1 в матрице плана на 0
    for (int i = 0; i < n; i++) { // Цикл по строкам плана
        for (int j = 0; j < k; j++) { // Цикл по столбцам плана
            if (Matr2[i][j] < 0) { // Если клетка осталась незаполненной (-1)
                Matr2[i][j] = 0; // Присваиваем ей значение 0
            }
        }
    }
    // --- КОНЕЦ: Финальная обработка матрицы плана ---

    // --- НАЧАЛО: Вывод результата и вычисление целевой функции ---
    cout << endl << "Опорный план методом минимального элемента:" << endl; // Заголовок для вывода плана
    int total_cost = 0; // Переменная для хранения общей стоимости перевозок

    for (int i = 0; i < n; i++) { // Цикл по строкам результирующей матрицы
        for (int j = 0; j < k; j++) { // Цикл по столбцам результирующей матрицы
            cout << Matr[i][j]; // Выводим стоимость перевозки
            if (Matr2[i][j] != 0) { // Если в плане поставок объем > 0
                cout << "(" << Matr2[i][j] << ")"; // Выводим объем в скобках после стоимости
            }
            cout << "\t"; // Вставляем табуляцию
            total_cost += Matr[i][j] * Matr2[i][j]; // Увеличиваем общую стоимость на c_ij * x_ij
        }
        cout << endl; // Переход на новую строку
    }

    cout << endl << "Матрица плана перевозок (X):" << endl; // Вывод самой матрицы плана
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < k; j++) {
            cout << Matr2[i][j] << "\t";
        }
        cout << endl;
    }

    cout << endl << "Значение целевой функции для этого опорного плана равно: " << total_cost << endl; // Выводим итоговую стоимость
    // --- КОНЕЦ: Вывод результата и вычисление целевой функции ---

    return 0; // Завершаем программу
}